# ICA
プログラミング基礎演習最終課題(2022/02/12)

# [課題1]
2つの信号源を異なる比率で混合したデータが2つ与えられているときに, ICAを適用することによって2つの信号源を同定することを行った。  

初めに与えられたデータをfreadによって読み込み, それぞれのデータの平均が0になるように調整してからデータの2次元配列data[][2]を作成する。そこから, レポート課題の説明文に従って共分散行列 (cov_matrix), 共分散行列の固有値(eigenvalues)と固有ベクトル(これらを並べた正則行列をコード上ではunique_matrixとしている)を求め, 行列 (ただし をみたす)を求める。そしてこれらの結果を用いて新しい確率変数 を導入する。  

続いて, 任意の初期値を持つ列ベクトル を導入し,  の尖度が最大となるように課題説明文に記載のある繰り返しアルゴリズムを実装する。この繰り返しアルゴリズムでは正規化を何度も行うことになるため正規化を行う関数regularize()を実装してコードをより簡潔にした。また繰り返しアルゴリズムのwhile文の終了条件は列ベクトル のそれぞれの要素の絶対値をとり, それらの変化量の絶対値が0.0000001を下回ったときとした。

何度か試しに実行し, 最終的に適切な２つの初期値をとることによって2つの信号源を別々に同定することができる行列 を得,  を計算して表示させる(matplotlib.pyplotを利用)ことによって以下のような2つの信号源を得ることができた。
 

# [課題2]
　2つの曲を同時に演奏したものを異なる場所で録音したデータが2つ与えられ, そこからICAを適用することによりそれぞれの曲を別々のデータに分離した。概ね方針は課題1と変わらないので実装の過程は割愛するが, 読み込むファイルがtxtファイルからwavファイルに変わったことによって留意したことを以下に記す。  
 
　読み込みはscipy.io.wavfile.readを用いて行ったが, 読み込みによって得られたファイル(コード上ではrawdata1, rawdata2)は上書き不可であったため, deepcopyをすることによって変更をできるようにした(data1, data2に該当)。また, 繰り返しアルゴリズム実行後に得られた行列 から信号源(それぞれの曲)を復元した際にそのままだと信号の大きさ(音量)が非常に小さくなってしまうため, 人が聞き取れる程度の大きさになるよう調整(今回の場合値を5000倍にした)を加えた。
 
 最後にwavファイルに書き出しをするときにscipy.io.wavfile.writeを用いたが, このモジュールは配列のdtypeがfloat64であるときに対応していないので強制的にint16にキャストした(もともとのrawdata1, rawdata2のdtypeがint16であったためそこに合わせた形である)。最終的に得られた音声ファイルを以下に添付する。ノイズもなく非常にきれいに分離できていることが確認できる。
 　 
　コードの最後にあるmatplotlibによる音声データの描画はおまけ程度であるが波形を重ねて表示すると全く別の波形に分離できていることが確認できる。

# [課題3]
　2つの画像が重なったファイルが2つ与えられているときに, ICAを適用することでこれらを元の画像に分離した。以下では課題2と同様にjpegファイルの読み込み/書き出しにおいて特に留意したことについて記す。
 
　まず読み込みに関してPILのImageというモジュールを用いて行った。今回は画像であるため得られるのは2次元配列となる。課題1と課題2でそれぞれのデータから得られる配列は1次元配列であったため, 課題1と課題2の方針と整合性がとれるように得られた2次元配列をnumpyモジュールのflatten関数を用いて1次元化し, 復元の際にreshape関数によって再び2次元配列に戻した。ここで, 得られる配列のdtypeを確認したところuint8であり, 負の値にも対応できるようにこれらの配列をint16に強制的にキャストした。また復元されたデータが課題1同様にかなり小さい値となってしまったため与えられた元画像と同じ程度の濃さになるように調整(今回の場合値を40倍にした)を加えた。
 
 最終的に得られた画像を以下に添付する。確かにきれいに別々の画像に分離できていることが確認できる。
  
